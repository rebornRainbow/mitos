## Race
 表示的是一种情况，几个线程同时对一个数据结构执行，其中至少有一个是写入，因为可能某些执行顺序会导致错误的发生，所以是一种错误

 ## lock
 锁确保互斥，

 锁保护的区域叫做临界区critical section

 作用：用来维持一种invariant：不发生改变的数据结构的属性，如果改变用来提供一个区域让其可以恢复
- 问如kfree中维持的invariant：是什么？是锁是怎么维护的？


缺点：锁的使用使得性能降低了


## 锁的类别：自旋锁和互斥锁
- 实现使用一种原子指令
    -   amoswap r, a 交换寄存器r,和内存地址a里面的内容
    -   加锁
        -   while(amoswap(1,lock->hold)!=1),//返回lock->hold的内容
            -   如果是1一直自旋
            -   入股是0就返回得到了锁，并且也上了锁，过程是原子的
    -  放锁
       -  先释放相关资源，然后将*lock->hold变成0


## 什么时候使用
当有一个数据结构被写入，但同时有可能被其他的线程写入的时候

或者是当数据结构的一个需要维持不变量可能发生改变时
- 比如一个head

### 粗粒度锁和细粒度锁

粗粒度锁：一个数据结构，有一个大锁保护，
- 如freelist

细粒度锁：一个数据结构分成多个部分，用不同的锁保护，目的是为了加快进度，
- 如操作系统的文件系统，每个文件都有一个锁保护，这就是细粒度锁

## 死锁
如果一个线程有几个锁，要确保不同线程的加锁的顺序都一样，不然会有发生死锁的可能
- 什么样的可能举个例子？A B两个锁两个线程

这个叫做锁链

而文件系统有最长的锁链

## 重入锁
定义就像它的名字允许线程再次进入

一般不用

想办法维持顺序

## 锁和中断处理器

一些锁保护中断和异常共同使用的数据

### 一些锁和中断处理器一起可能会导致死锁

比如如果一个系统调用sleep,获得了tickslock，然后引发了时间中断就会导致死锁的发生

这时要解决就要我们用一些办法来规避这些情况，
我们需要保证在我们获取自旋锁的时候，没有开启中断，

并且需要确保当前的CPU没有自旋锁的时候才再次开启中断

pushoff也会关闭终端

这需要我们记录加的锁acquire(锁)的时候会调pushoff方法，release(锁)的时候会调用popoff()方法

当在popoff中计数达到0的时候会开启中断

#### 时机

只有在pushoff之后才能设置锁，不然会有一个短暂的窗口期，加锁了，但是没有关中断

只有在l->locked处理了之后才能popoff(),不然，中断开了，但是没有解锁，

## 指令顺序和内存顺序

有时候编译器出于优化的目的会改变某些代码的顺序，甚至是忽略某些代码。
这如果刚好发生在临界区的代码上，可能会引发极难察觉的错误，所以操作系统
提供了一种原语来阻止这种事情的发生

xv6提供了一个方法sync_synchronize()这是一个内存同步（memory barrier）指令，告诉编译器重新执行的
load和store指令的顺序的时候不要跨越这个障碍

## 睡眠锁
